\documentclass[12pt, a4paper]{article}
\usepackage{sectsty}
\sectionfont{\fontsize{12}{15}\selectfont}
\subsectionfont{\fontsize{10}{12}\selectfont}
\begin{document}
\title{"Planning and Heuristic Search" \\ Oral Pre-Exam Questions (WS 2018/19)}
\date{}
\maketitle
%\input{oral-questions-1}
\section{What are nodes and edges representing in an OR graph?}
Nodes represent states of a given problem (e.g. board configurations in the 8-puzzle). Edges represent operations (solution steps) that should simplify the problem.


\section{What is a solution path in an OR-graph?}
A path \textit{P} in a state-space graph \textit{G} from node \textit{n} to goal node $\gamma$ in \textit{G}, satisfying given solution constraint,  is called a \textit{solution path} for \textit{n}. 
\subsection*{What is a solution base?}
A path \textit{P} in \textit{G} from \textit{n} to some node \textit{n'} is called \textit{solution base} for \textit{n}.


\section{What are constraint satisfaction problems? What are optimization problems?}
Constraint satisfaction problems are problems where a solution has to fulfill certain constraints and shall be found with minimum search effort. Optimization problems have to find a solution that in addition to the satisfication of constraints also has to stand out amongst all other solutions with respect to a special property.


\section{What is an appropriate representation for infinite graphs?}
The implicit representation is appropriate for infinite graphs as it uses the computable methods \textit{successors()} or \textit{next\_successor()} to determine the direct successors of a node. Its counterpart the explicit representation can only handle finite graphs, as the graph G = (V, E) is explicitly definied.


\section{What is node expansion?}
Applying the function \textit{successors(n)} on a node \textit{n} and thereby creating all direct successors of this node in \textbf{one time step} is called \textit{node expansion}. (All algorithms we considered use node expansion as a basic step, except for the backtracking algorithm)
\subsection*{What is node generation?}
Applying the function \textit{next\_successor(n)} on a node \textit{n} and thereby creating an unseen direct successor (one at a time) is called \textit{node generation}.
\subsection*{What are the states of nodes?} \begin{itemize}
\item generated (living on OPEN)
\item explored (neither on OPEN or CLOSED in A*, since it means \textit{next\_succesor} was applied and there is still at least one unseen node which will be returned by the next call of \textit{next\_succesor}.)
\item expanded (living on CLOSED, except for reopening in A*)
\item unseen
\end{itemize}

\section{What are locally finite graphs? Why do we need them?}
Local finitness means that a node has only a finite number of direct succesors. We do need this property as otherwise we would be stuck in an infinite loop when calling the methods \textit{succesors} or \textit{next\_succesor}.

\section{What is a solution base (differences to solution paths)?}
See question 2. Informally it is the inital part of a possible solution path. Note that we don't necessarily need to find a goal node when following expanding a solution base.

\section{What is an efficient way of representing solution bases?}
Solution bases can be efficiently represented by a \textbf{backpointer path}. A \textit{backpointer} is a reference of a newly generated node, pointing to its parent.

\section{What is the tree Basic-OR-Search maintains?}
The tree maintained by Basic-OR-Search is called a \textit{traversal tree}. It is rooted in the start node \textit{s} and definied by node instances from \textit{G} and edges reverse to the backpointers. Path (\textit{n}, \ldots, \textit{s}), defined by the backpointers of the nodes, is reversed in the traversal tree as (\textit{s}, \ldots, \textit{n}) and is called a backpointer path.

\section{Why is the graph maintained by Basic-OR-Search a tree?}
(A traversal tree is not directly maintained by an algorithm, hence this question is not exact.) It is called traversal tree, because it is a tree-unfolding of a part of the explored subgraph of \textit{G}. Every instance of a node can only have one parent,as it only got one backpointer reference. We don't have cycles because a node in \textit{G} is represented by multiple instances in the traversal tree (if the node got multiple successors that is).

\section{Why is the traversal tree in Basic-OR-Search no subgraph of the OR-graph?}
In general traversal trees are no subgraphs of the  search space graph \textit{G} because traversal trees can contain multiple instances of nodes in \textit{G}.

\section{Are DFS and BFS variants of Basic-OR-Search? Why? / Why not?}
TODO \\
DFS uses a \textit{stack} as OPEN list, hence it uses the LIFO principle.
BFS on the other hand uses a \textit{queue} as OPEN list, hence it uses the FIFO principle.
Both algorithems can be converted into each other by only changing the implementation of the data structure of the OPEN list.
\ldots

\section{Comparison of DFS and BFS: Which algorithm is to be preferred when and why?}
DFS is preferred when:
\begin{itemize}
\item We are given plenty of equivalent solutions.
\item Dead ends can be recognized early, i.e. with considerable look-ahead.
\item There are no cyclic or infinite paths (or at least they can be avoided).
\end{itemize}
BFS is preferred when:
\begin{itemize}
\item We know a solution is not far away from the start node.
\item Solutions are rare and the tree is deep. (Because DFS will take way longer on those graphs.)
\item \ldots 
\end{itemize}
An issue with BFS is that it has to store the explored part of the graph completley in memory. So when a graph is very wide, BFS will need too much memory. However, with BFS we do terminate with a solution if one exists, whereas DFS could follow an endless frutiless path.

\section{Which nodes are stored on OPEN, which nodes on CLOSED?}
Nodes waiting to be expanded are storted on OPEN (this includes both \textit{generated} and \textit{explored} nodes which have not been expanded yet), whereas already expanded nodes are stored on CLOSED.

\section{Why is a function cleanup\_closed() needed in DFS?}
It is needed in order to not run out of memory because of nodes we actually don't need to reference anymore. The function \textit{cleanup\_closed} deletes nodes from the CLOSED list that are no longer required. It is based on the principles that nodes which fulfill the dead end requirement can be discarded without hesitation. If a node \textit{n} is discarded, check if  \textit{n} has any predecessors that are still part of a solution path. A node is part of a solution path if it has a successors on OPEN. Predecessors that are not part of a solution path can be discarded.

\section{What is iterative deepening?}
Increasing the depth-bound of DFS in an outerloop and run DFS with an increased depth-bound value \textit{k} over and over again.

\end{document}